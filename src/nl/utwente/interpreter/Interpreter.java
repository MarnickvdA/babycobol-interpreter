package nl.utwente.interpreter;

import nl.utwente.interpreter.model.ProgramOutput;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.*;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class Interpreter {

    /**
     * The number of errors detected by the lexer and parser.
     */
    private int errorCount = 0;
    BabyCobolParser parser;
    BabyCobolLexer lexer;
    Visitor visitor;

    public static void main(String[] args) {
        Interpreter interpreter = new Interpreter();

        if (args.length != 2 && !args[0].equals("--path")) {
            throw new RuntimeException("Invalid input");
        }

        String filename = args[1];

        try {
            InputStream inputStream = new FileInputStream(filename);
            CharStream charStream = CharStreams.fromStream(inputStream);

            interpreter.compile(charStream);
            inputStream.close();
        } catch (IOException ex) {
            System.err.println(ex.getLocalizedMessage());
        }
    }

    public Interpreter() {

    }

    /**
     * calls the actual compile method
     */
    public void compile(CharStream input) throws IOException {
        compile(input, new ProgramOutput());
    }

    /**
     * Compiles a file. The source code is lexed (turned into tokens), parsed (a parse tree
     * created).
     *
     * @param input          Stream to the source code input.
     * @throws IOException       if files could not be read or written
     */
    public void compile(CharStream input, ProgramOutput programOutput) throws IOException {
        // Phase 1: Run the lexer
        CommonTokenStream tokens = runLexer(input);

        // Phase 2: Run the parser
        ParseTree parseTree = runParser(tokens);

        // ANTLR tries to do its best in creating a parse tree, even if the source code contains
        // errors. So, check if that is the case and bail out if so.
        if (errorCount > 0)
            return;

        // Phase 3: Check the source code for semantic errors
        runVisitor(parseTree, programOutput);
    }

    /**
     * Take the charater input and turn it into tokens according to the grammar.
     *
     * @param input The input.
     * @return A steam of tokens.
     */
    private CommonTokenStream runLexer(CharStream input) {
        lexer = new BabyCobolLexer(input);
        lexer.addErrorListener(getErrorListener());
        return new CommonTokenStream(lexer);
    }

    /**
     * Tries to form a parse tree from the given tokens. In case of errors, the error listener is
     * called, but the parser still tries to create a parse tree.
     *
     * @param tokens The tokens returned from the lexer.
     * @return A Parse Tree.
     */
    private ParseTree runParser(CommonTokenStream tokens) {
        parser = new BabyCobolParser(tokens);
        parser.addErrorListener(getErrorListener());
        return parser.program();
    }

    /**
     * Called to check if the source code was semantically correct. This method is only called when
     * there were no syntax errors.
     *
     * @param parseTree The parse tree generated by the parser
     * @return True if all code is semantically correct
     */
    private boolean runVisitor(ParseTree parseTree, ProgramOutput programOutput) {
        visitor = new Visitor(programOutput);
        visitor.visit(parseTree);
        return true;
    }


    /**
     * Creates and returns an error listener for use in the lexer and parser that just increases
     * the errorCount-attribute in this class so we can find out if the source code had a syntax
     * error.
     *
     * @return An error listener for use with lexer.addErrorListener() and parser.addErrorListener()
     */
    private ANTLRErrorListener getErrorListener() {
        return new BaseErrorListener() {
            @Override
            public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol,
                                    int line, int charPositionInLine,
                                    String msg, RecognitionException e) {
                errorCount++;
            }
        };
    }
}
